package syncer

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

// CheckGHInstalled verifies that the GitHub CLI is installed
func CheckGHInstalled() error {
	cmd := exec.Command("gh", "--version")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("GitHub CLI (gh) is not installed. Please install it from https://cli.github.com")
	}
	return nil
}

// CheckGHAuth verifies that the user is authenticated with GitHub CLI
func CheckGHAuth() error {
	cmd := exec.Command("gh", "auth", "status")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("not authenticated with GitHub CLI. Run 'gh auth login' first.\n%s", stderr.String())
	}
	return nil
}

// CloneRepo clones a repository to the specified directory using shallow clone
func CloneRepo(repo, destDir string) error {
	// Use gh repo clone which handles auth automatically
	cmd := exec.Command("gh", "repo", "clone", repo, destDir, "--", "--depth=1")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("clone failed: %s", stderr.String())
	}
	return nil
}

// IsEmptyRepo checks if the repository has any commits
func IsEmptyRepo(repoDir string) bool {
	cmd := exec.Command("git", "rev-parse", "HEAD")
	cmd.Dir = repoDir
	err := cmd.Run()
	// If HEAD doesn't exist, the repo is empty
	return err != nil
}

// CreateBranch creates and checks out a new branch in the repository
// For empty repos, it creates an orphan branch on the target branch name
func CreateBranch(repoDir, branchName, baseBranch string) error {
	// Check if this is an empty repo
	if IsEmptyRepo(repoDir) {
		// For empty repos, we'll work directly on the target branch
		// Create an orphan branch with the target branch name
		cmd := exec.Command("git", "checkout", "--orphan", baseBranch)
		cmd.Dir = repoDir
		var stderr bytes.Buffer
		cmd.Stderr = &stderr

		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to create initial branch: %s", stderr.String())
		}
		return nil
	}

	// For non-empty repos, checkout the base branch first
	cmd := exec.Command("git", "checkout", baseBranch)
	cmd.Dir = repoDir
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to checkout %s: %s", baseBranch, stderr.String())
	}

	// Create and checkout new branch
	cmd = exec.Command("git", "checkout", "-b", branchName)
	cmd.Dir = repoDir
	stderr.Reset()
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to create branch: %s", stderr.String())
	}
	return nil
}

// HasChanges checks if there are any uncommitted changes in the repository
func HasChanges(repoDir string) (bool, error) {
	// Stage all changes first
	cmd := exec.Command("git", "add", "-A")
	cmd.Dir = repoDir
	if err := cmd.Run(); err != nil {
		return false, fmt.Errorf("failed to stage changes: %w", err)
	}

	// Check for staged changes
	cmd = exec.Command("git", "diff", "--cached", "--quiet")
	cmd.Dir = repoDir

	err := cmd.Run()
	if err != nil {
		// Exit code 1 means there are changes
		if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
			return true, nil
		}
		return false, err
	}

	// Exit code 0 means no changes
	return false, nil
}

// CommitAndPush commits all staged changes and pushes to remote
func CommitAndPush(repoDir, message string) error {
	// Commit
	cmd := exec.Command("git", "commit", "-m", message)
	cmd.Dir = repoDir
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("commit failed: %s", stderr.String())
	}

	// Push with -u to set upstream
	cmd = exec.Command("git", "push", "-u", "origin", "HEAD")
	cmd.Dir = repoDir
	stderr.Reset()
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("push failed: %s", stderr.String())
	}

	return nil
}

// CreatePR creates a pull request and returns the PR URL
func CreatePR(repo, branchName, baseBranch string) (string, error) {
	title := "chore: update AI agent configurations"
	body := `## Summary
Automated update of AI coding assistant configurations.

Generated by [agentspack](https://github.com/agentspack/agentspack).

## Changes
- Updated configuration files for AI coding assistants
- Synced latest templates and rules`

	cmd := exec.Command("gh", "pr", "create",
		"--repo", repo,
		"--head", branchName,
		"--base", baseBranch,
		"--title", title,
		"--body", body,
	)

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("PR creation failed: %s", stderr.String())
	}

	// gh pr create outputs the PR URL
	prURL := strings.TrimSpace(stdout.String())
	return prURL, nil
}

// MergeBranch merges the branch into the target branch locally and pushes
func MergeBranch(repoDir, branchName, targetBranch string) error {
	// Checkout target branch
	cmd := exec.Command("git", "checkout", targetBranch)
	cmd.Dir = repoDir
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to checkout %s: %s", targetBranch, stderr.String())
	}

	// Merge the branch
	cmd = exec.Command("git", "merge", branchName, "--no-edit")
	cmd.Dir = repoDir
	stderr.Reset()
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("merge failed: %s", stderr.String())
	}

	// Push
	cmd = exec.Command("git", "push", "origin", targetBranch)
	cmd.Dir = repoDir
	stderr.Reset()
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("push failed: %s", stderr.String())
	}

	// Delete the feature branch (cleanup)
	cmd = exec.Command("git", "branch", "-d", branchName)
	cmd.Dir = repoDir
	// Ignore errors on branch deletion, it's just cleanup

	cmd = exec.Command("git", "push", "origin", "--delete", branchName)
	cmd.Dir = repoDir
	// Ignore errors on remote branch deletion too

	return nil
}
